


最近碰到了几次数据库响应变慢的问题，整理了一下处理的流程和分析思路，执行脚本。希望对其他人有帮助。

MySQL慢查询表现
明显感觉到大部分的应用功能都变慢，但也不是完全不能工作，等待比较长的时间还是有响应的。但是整个系统看起来就非常的卡。

查询慢查询数量
一般来说一个正常运行的MySQL服务器，每分钟的慢查询在个位数是正常的，偶尔飙升到两位数也不是不能接受，接近100系统可能就有问题了，但是还能勉强用。这几次出问题慢查询的数量已经到了1000多。

慢查询的数量保存在mysql库里面的slow_log表。

SELECT * FROM slow_log where start_time > '2019/05/19 00:00:00'; 
这样就能查出一天以来的慢查询了。

查看当前进行的查询状态
大家应该都比较常用show processlist来查看当前系统中正在执行的查询，其实这些数据也保存在information_schema库里面的processlist表，因此如果要做条件查询，直接查询这张表更方便。

比如查看当前所有的process

select * from information_schema.processlist 
查看当前正在进行的查询并按照已经执行时间倒排

select * from information_schema.processlist where info is not null order by time desc 
正常运行的数据库，因为一条查询的执行速度很快，被我们的select抓到的info不是null的查询数量会很少。我们这样负荷很大的库一般也就只能查到几条。如果一次能查到info非空的查询有几十条，那么也可以认为系统出问题了。

系统问题和定位
当我们察觉到系统变慢之后，马上用慢查询和查看processlist的方式做了检查，结果发现每分钟慢查询数量飙升到1000多，同时淤积了大量的查询在执行中。

因为当务之急是尽快恢复系统的正常运行，因此影响最直接的做法是在processlist的查询结果中，查看有多少哪些查询处于lock状态，或者已经执行了很长时间，把这些process用kill指令干掉。通过不停的杀死这些可能会引发系统阻塞的process，最终能够暂时让系统逐步恢复到正常状态，当然这只是权宜之计。

此外，最重要的当然是分析到底是哪些查询为什么会引发系统阻塞，我们还是使用慢查询来做分析。

慢查询表查询结果里面有几个比较重要的指标：

start_time 开始时间，要通过这个参数，配合系统出问题的时间，定位哪些查询是罪魁祸首。

query_time 查询时间

rows_sent 和 rows_examined发送的结果数以及查询扫过的行数，这两个值特别重要，特别是 rows_examined。基本上就能告诉我们，哪个查询是需要注意的“大”查询。

实际操作中，我们也是把有大量rows_examined的查询一个个拿出来分析，添加索引，修改查询语句的编写，来彻底的解决问题。

处理结果和反思
经过对所有慢查询的检查和整改，目前MySQL每分钟慢查询数徘徊在1~2之间，CPU的负荷也非常低。问题算是基本得到了解决。

反思一下问题出现的原因，有几个地方需要注意：

数据库出问题往往不是上线即引发问题，而是有一个累积的过程，不断累加的糟糕的查询语句会逐步增加系统负载，最后压倒骆驼的最后一根稻草往往看上去莫名其妙
最后的一根稻草甚至有可能根本不存在，不是一次发版或者是功能上线，而是随着用户使用量上升，数据量的累积而爆发
既然问题的出现是累积的过程，就需要在每次代码发版之前做好review
索引的添加很重要
慢查询的监控也需要纳入到Zabbix的监控范围

